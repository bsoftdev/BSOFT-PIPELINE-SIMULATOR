<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Pipeline de Instruções</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    <style>
        :root {
            --primary-color: #6a11cb;
            --secondary-color: #2575fc;
            --hazard-color: #ff6b6b;
            --stall-color: #ffd166;
            --forwarding-color: #06d6a0;
            --success-color: #28a745;
        }
        
        body {
            background-color: #f8f9fa;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .header {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: white;
            padding: 2rem 0;
            margin-bottom: 2rem;
            border-radius: 0 0 10px 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        
        .card {
            border: none;
            border-radius: 10px;
            box-shadow: 0 6px 15px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        }
        
        .card-header {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: white;
            font-weight: bold;
            border-radius: 10px 10px 0 0 !important;
        }
        
        .pipeline-container {
            overflow-x: auto;
            padding-bottom: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.05);
        }
        
        .pipeline-grid {
            display: grid;
            grid-template-columns: 100px repeat(20, 120px);
            gap: 2px;
            padding: 10px;
            min-width: 100%;
        }
        
        .pipeline-header {
            font-weight: bold;
            text-align: center;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 5px;
            position: sticky;
            left: 0;
            z-index: 2;
        }
        
        .pipeline-cell {
            height: 60px;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            position: relative;
            transition: all 0.3s;
        }
        
        .pipeline-cell.empty {
            background-color: #f8f9fa;
        }
        
        .pipeline-cell.filled {
            background-color: var(--secondary-color);
            color: white;
            font-weight: bold;
            animation: fadeIn 0.5s;
        }
        
        .pipeline-cell.hazard {
            background-color: var(--hazard-color);
            animation: pulse 1.5s infinite;
        }
        
        .pipeline-cell.stall {
            background-color: var(--stall-color);
        }
        
        .pipeline-cell.forwarding {
            background-color: var(--forwarding-color);
        }
        
        .pipeline-cell.structural {
            background-color: #ff9ff3;
        }
        
        .instruction-card {
            background-color: white;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            border-left: 4px solid var(--primary-color);
            transition: all 0.3s;
            cursor: grab;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        .instruction-card:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .instruction-card.add {
            border-left-color: #28a745;
        }
        
        .instruction-card.load {
            border-left-color: #17a2b8;
        }
        
        .instruction-card.store {
            border-left-color: #ffc107;
        }
        
        .instruction-card.branch {
            border-left-color: #dc3545;
        }
        
        .instruction-card.nop {
            border-left-color: #6c757d;
        }
        
        .performance-metric {
            font-size: 1.1rem;
            padding: 8px;
            border-radius: 5px;
            background-color: #f8f9fa;
            margin-bottom: 5px;
        }
        
        .performance-metric span {
            font-weight: bold;
            color: var(--primary-color);
        }
        
        .btn-gradient {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: white;
            border: none;
            border-radius: 30px;
            padding: 8px 20px;
            font-weight: 500;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: all 0.3s;
        }
        
        .btn-gradient:hover {
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 70%);
        }
        
        .stage-indicator {
            height: 10px;
            width: 100%;
            border-radius: 5px;
            margin-top: 5px;
        }
        
        .stage-if { background-color: #007bff; }
        .stage-id { background-color: #28a745; }
        .stage-ex { background-color: #ffc107; }
        .stage-mem { background-color: #17a2b8; }
        .stage-wb { background-color: #dc3545; }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.03); }
            100% { transform: scale(1); }
        }
        
        @keyframes slideIn {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .animate-slide-in {
            animation: slideIn 0.5s forwards;
        }
        
        .tooltip-inner {
            max-width: 300px;
            padding: 10px;
        }
        
        .progress {
            height: 10px;
            border-radius: 5px;
        }
        
        .progress-bar {
            background-color: var(--primary-color);
            transition: width 0.6s ease;
        }
    </style>
</head>
<body>
    <div class="header text-center animate__animated animate__fadeIn">
        <div class="container">
            <h1 class="display-4 fw-bold">BSOFT PIPELINE SIMULATOR</h1>
            <p class="lead">Visualize o funcionamento interno de processadores com pipeline</p>
        </div>
    </div>

    <div class="container">
        <div class="row">
            <div class="col-lg-8">
                <div class="card animate__animated animate__fadeInLeft">
                    <div class="card-header">
                        Visualização do Pipeline
                    </div>
                    <div class="card-body">
                        <div class="pipeline-container">
                            <div class="pipeline-grid" id="pipelineGrid">
                                <!-- Pipeline stages will be generated here -->
                            </div>
                        </div>
                        <div class="d-flex justify-content-between mt-3">
                            <div class="d-flex align-items-center">
                                <div class="me-2" style="width: 15px; height: 15px; background-color: var(--secondary-color); border-radius: 3px;"></div>
                                <small>Execução normal</small>
                            </div>
                            <div class="d-flex align-items-center">
                                <div class="me-2" style="width: 15px; height: 15px; background-color: var(--hazard-color); border-radius: 3px;"></div>
                                <small>Hazard detectado</small>
                            </div>
                            <div class="d-flex align-items-center">
                                <div class="me-2" style="width: 15px; height: 15px; background-color: var(--stall-color); border-radius: 3px;"></div>
                                <small>Stall (atraso)</small>
                            </div>
                            <div class="d-flex align-items-center">
                                <div class="me-2" style="width: 15px; height: 15px; background-color: var(--forwarding-color); border-radius: 3px;"></div>
                                <small>Forwarding</small>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="card animate__animated animate__fadeInLeft animate__delay-1s">
                    <div class="card-header">
                        Instruções
                    </div>
                    <div class="card-body">
                        <div id="instructionsContainer" class="mb-3">
                            <!-- Instructions will be added here -->
                        </div>
                        <div class="d-flex justify-content-between">
                            <button class="btn btn-gradient me-2" id="addInstructionBtn">
                                <i class="fas fa-plus me-1"></i> Adicionar Instrução
                            </button>
                            <button class="btn btn-outline-secondary" id="clearPipelineBtn">
                                <i class="fas fa-trash-alt me-1"></i> Limpar Tudo
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="col-lg-4">
                <div class="card animate__animated animate__fadeInRight">
                    <div class="card-header">
                        Controles
                    </div>
                    <div class="card-body">
                        <div class="d-grid gap-2 mb-3">
                            <button class="btn btn-gradient" id="runPipelineBtn">
                                <i class="fas fa-play me-1"></i> Executar Pipeline
                            </button>
                            <button class="btn btn-outline-primary" id="stepPipelineBtn">
                                <i class="fas fa-step-forward me-1"></i> Passo a Passo
                            </button>
                            <button class="btn btn-outline-danger" id="resetPipelineBtn">
                                <i class="fas fa-undo me-1"></i> Resetar
                            </button>
                        </div>
                        
                        <div class="form-check form-switch mb-3">
                            <input class="form-check-input" type="checkbox" id="forwardingToggle" checked>
                            <label class="form-check-label" for="forwardingToggle">Ativar Forwarding</label>
                        </div>
                        <div class="form-check form-switch mb-3">
                            <input class="form-check-input" type="checkbox" id="hazardDetectionToggle" checked>
                            <label class="form-check-label" for="hazardDetectionToggle">Detecção de Hazards</label>
                        </div>
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="animationToggle" checked>
                            <label class="form-check-label" for="animationToggle">Ativar Animações</label>
                        </div>
                    </div>
                </div>

                <div class="card animate__animated animate__fadeInRight animate__delay-1s mt-4">
                    <div class="card-header">
                        Métricas de Desempenho
                    </div>
                    <div class="card-body">
                        <div class="performance-metric">
                            Ciclos: <span id="cycleCount">0</span>
                        </div>
                        <div class="performance-metric">
                            Instruções: <span id="instructionCount">0</span>
                        </div>
                        <div class="performance-metric">
                            CPI: <span id="cpi">0.00</span> (ciclos por instrução)
                        </div>
                        <div class="performance-metric">
                            Throughput: <span id="throughput">0.00</span> inst/ciclo
                        </div>
                        <div class="performance-metric">
                            Stalls: <span id="stallCount">0</span>
                        </div>
                        <div class="performance-metric">
                            Hazards: <span id="hazardCount">0</span>
                        </div>
                        <div class="progress mt-3">
                            <div id="efficiencyBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                        </div>
                        <small class="text-muted">Eficiência do Pipeline</small>
                    </div>
                </div>

                <div class="card animate__animated animate__fadeInRight animate__delay-2s mt-4">
                    <div class="card-header">
                        Estágios do Pipeline
                    </div>
                    <div class="card-body">
                        <div class="mb-2">
                            <strong>IF</strong> - Busca da Instrução
                            <div class="stage-indicator stage-if"></div>
                        </div>
                        <div class="mb-2">
                            <strong>ID</strong> - Decodificação
                            <div class="stage-indicator stage-id"></div>
                        </div>
                        <div class="mb-2">
                            <strong>EX</strong> - Execução
                            <div class="stage-indicator stage-ex"></div>
                        </div>
                        <div class="mb-2">
                            <strong>MEM</strong> - Acesso à Memória
                            <div class="stage-indicator stage-mem"></div>
                        </div>
                        <div>
                            <strong>WB</strong> - Write Back
                            <div class="stage-indicator stage-wb"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="row mt-4">
            <div class="col-12">
                <div class="card animate__animated animate__fadeInUp animate__delay-2s">
                    <div class="card-header">
                        Tipos de Hazards
                    </div>
                    <div class="card-body">
                        <div class="row">
                            <div class="col-md-4 mb-3">
                                <div class="card h-100 border-danger">
                                    <div class="card-header bg-danger text-white">
                                        Data Hazard (RAW)
                                    </div>
                                    <div class="card-body">
                                        <p>Ocorre quando uma instrução precisa ler um registrador que ainda não foi escrito por uma instrução anterior.</p>
                                        <p class="text-muted">Exemplo: ADD R1,R2,R3 seguido por SUB R4,R1,R5</p>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-4 mb-3">
                                <div class="card h-100 border-warning">
                                    <div class="card-header bg-warning text-dark">
                                        Control Hazard
                                    </div>
                                    <div class="card-body">
                                        <p>Ocorre com instruções de desvio (branch) onde o processador não sabe imediatamente para onde saltar.</p>
                                        <p class="text-muted">Exemplo: BEQ R1,R2,Label seguido por instruções que podem ser descartadas</p>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-4 mb-3">
                                <div class="card h-100 border-info">
                                    <div class="card-header bg-info text-white">
                                        Structural Hazard
                                    </div>
                                    <div class="card-body">
                                        <p>Ocorre quando duas instruções precisam do mesmo recurso de hardware ao mesmo tempo.</p>
                                        <p class="text-muted">Exemplo: Duas instruções tentando acessar a memória simultaneamente</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal para adicionar nova instrução -->
    <div class="modal fade" id="instructionModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Adicionar Nova Instrução</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="instructionType" class="form-label">Tipo de Instrução</label>
                        <select class="form-select" id="instructionType">
                            <option value="add">ADD - Soma</option>
                            <option value="sub">SUB - Subtração</option>
                            <option value="load">LW - Load Word</option>
                            <option value="store">SW - Store Word</option>
                            <option value="branch">BEQ - Branch if Equal</option>
                            <option value="nop">NOP - No Operation</option>
                        </select>
                    </div>
                    
                    <div id="operandsContainer">
                        <!-- Operand fields will be generated here -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                    <button type="button" class="btn btn-primary" id="confirmAddInstruction">Adicionar</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.14.0/Sortable.min.js"></script>
    <script src="https://kit.fontawesome.com/a076d05399.js" crossorigin="anonymous"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Configuração do Pipeline
            const STAGES = ['IF', 'ID', 'EX', 'MEM', 'WB'];
            const MAX_CYCLES = 15;
            let currentCycle = 0;
            let instructions = [];
            let pipelineState = Array(STAGES.length).fill().map(() => Array(MAX_CYCLES).fill(null));
            let performanceMetrics = {
                cycles: 0,
                instructions: 0,
                stalls: 0,
                hazards: 0,
                dataHazards: 0,
                controlHazards: 0,
                structuralHazards: 0
            };
            let isRunning = false;
            let forwardingEnabled = true;
            let hazardDetectionEnabled = true;
            let animationsEnabled = true;
            let instructionIdCounter = 0;

            // Inicializa o grid do pipeline
            function initializePipelineGrid() {
                const pipelineGrid = document.getElementById('pipelineGrid');
                pipelineGrid.innerHTML = '';
                
                // Cabeçalho vazio para alinhamento
                const emptyHeader = document.createElement('div');
                emptyHeader.className = 'pipeline-header';
                emptyHeader.style.gridColumn = '1 / span 1';
                emptyHeader.style.gridRow = '1 / span 1';
                pipelineGrid.appendChild(emptyHeader);
                
                // Cabeçalhos dos ciclos
                for (let i = 0; i < MAX_CYCLES; i++) {
                    const cycleHeader = document.createElement('div');
                    cycleHeader.className = 'pipeline-header';
                    cycleHeader.textContent = `Ciclo ${i}`;
                    cycleHeader.style.gridColumn = `${i + 2} / span 1`;
                    cycleHeader.style.gridRow = '1 / span 1';
                    pipelineGrid.appendChild(cycleHeader);
                }
                
                // Linhas para cada estágio
                for (let stageIndex = 0; stageIndex < STAGES.length; stageIndex++) {
                    const stage = STAGES[stageIndex];
                    
                    // Label do estágio
                    const stageLabel = document.createElement('div');
                    stageLabel.className = 'pipeline-header';
                    stageLabel.textContent = stage;
                    stageLabel.style.gridRow = `${stageIndex + 2} / span 1`;
                    pipelineGrid.appendChild(stageLabel);
                    
                    // Células para cada ciclo
                    for (let cycle = 0; cycle < MAX_CYCLES; cycle++) {
                        const cell = document.createElement('div');
                        cell.className = 'pipeline-cell empty';
                        cell.id = `cell-${stage}-${cycle}`;
                        cell.style.gridColumn = `${cycle + 2} / span 1`;
                        cell.style.gridRow = `${stageIndex + 2} / span 1`;
                        pipelineGrid.appendChild(cell);
                    }
                }
            }

            // Adiciona uma nova instrução à lista
            function addInstruction(text, type, id = null) {
                const container = document.getElementById('instructionsContainer');
                const newInstruction = document.createElement('div');
                
                if (!id) {
                    id = `inst-${instructionIdCounter++}`;
                }
                
                newInstruction.className = `instruction-card animate-slide-in ${type}`;
                newInstruction.id = id;
                newInstruction.draggable = true;
                
                const instructionContent = document.createElement('div');
                instructionContent.className = 'd-flex justify-content-between align-items-center';
                
                const instructionText = document.createElement('span');
                instructionText.textContent = text;
                instructionText.className = 'font-monospace';
                
                const instructionBadge = document.createElement('span');
                instructionBadge.className = 'badge rounded-pill';
                
                // Define a cor do badge baseado no tipo de instrução
                switch(type) {
                    case 'add':
                        instructionBadge.className += ' bg-success';
                        instructionBadge.textContent = 'ADD';
                        break;
                    case 'sub':
                        instructionBadge.className += ' bg-success';
                        instructionBadge.textContent = 'SUB';
                        break;
                    case 'load':
                        instructionBadge.className += ' bg-info';
                        instructionBadge.textContent = 'LW';
                        break;
                    case 'store':
                        instructionBadge.className += ' bg-warning text-dark';
                        instructionBadge.textContent = 'SW';
                        break;
                    case 'branch':
                        instructionBadge.className += ' bg-danger';
                        instructionBadge.textContent = 'BEQ';
                        break;
                    case 'nop':
                        instructionBadge.className += ' bg-secondary';
                        instructionBadge.textContent = 'NOP';
                        break;
                }
                
                instructionContent.appendChild(instructionText);
                instructionContent.appendChild(instructionBadge);
                newInstruction.appendChild(instructionContent);
                
                // Adiciona tooltip com informações da instrução
                newInstruction.setAttribute('data-bs-toggle', 'tooltip');
                newInstruction.setAttribute('title', getInstructionDescription(type));
                
                container.appendChild(newInstruction);
                instructions.push({text, type, id});
                
                // Atualiza contagem de instruções
                performanceMetrics.instructions = instructions.length;
                updatePerformanceMetrics();
                
                // Inicializa tooltip
                new bootstrap.Tooltip(newInstruction);
                
                return id;
            }

            // Retorna a descrição da instrução para o tooltip
            function getInstructionDescription(type) {
                switch(type) {
                    case 'add': return 'ADD Rd, Rs, Rt - Soma os valores de Rs e Rt, armazena em Rd';
                    case 'sub': return 'SUB Rd, Rs, Rt - Subtrai Rt de Rs, armazena em Rd';
                    case 'load': return 'LW Rt, offset(Rs) - Carrega palavra da memória[Rs+offset] para Rt';
                    case 'store': return 'SW Rt, offset(Rs) - Armazena palavra de Rt em memória[Rs+offset]';
                    case 'branch': return 'BEQ Rs, Rt, label - Salta para label se Rs == Rt';
                    case 'nop': return 'NOP - No Operation, não faz nada';
                    default: return 'Instrução desconhecida';
                }
            }

            // Avança um ciclo no pipeline
  function stepPipeline() {
    if (currentCycle >= MAX_CYCLES) {
        alert('Número máximo de ciclos alcançado!');
        return;
    }

    // 1. Primeiro movemos todas as instruções um estágio para frente
    for (let stage = STAGES.length - 1; stage > 0; stage--) {
        for (let cycle = MAX_CYCLES - 1; cycle > 0; cycle--) {
            // Move a instrução para o próximo estágio no próximo ciclo
            if (pipelineState[stage-1][cycle-1]) {
                pipelineState[stage][cycle] = {...pipelineState[stage-1][cycle-1]};
            } else {
                pipelineState[stage][cycle] = null;
            }
        }
    }

    // 2. Limpa o primeiro ciclo de cada estágio (exceto IF)
    for (let stage = 1; stage < STAGES.length; stage++) {
        pipelineState[stage][0] = null;
    }

    // 3. Busca nova instrução se houver
    if (currentCycle < instructions.length) {
        const instruction = instructions[currentCycle];
        pipelineState[0][currentCycle] = {
            instruction: instruction.text,
            type: instruction.type,
            id: instruction.id
        };
    } else {
        pipelineState[0][currentCycle] = null;
    }

    // 4. Detecta e trata hazards
    detectHazards();

    // 5. Atualiza a visualização
    updatePipelineVisualization();

    // 6. Incrementa contador de ciclos
    currentCycle++;
    performanceMetrics.cycles = currentCycle;
    updatePerformanceMetrics();
}

            // Executa o pipeline continuamente
            function runPipeline() {
                if (isRunning) return;
                
                isRunning = true;
                resetPipeline();
                
                const interval = setInterval(() => {
                    stepPipeline();
                    
                    if (currentCycle >= MAX_CYCLES) {
                        clearInterval(interval);
                        isRunning = false;
                    }
                }, 1000);
            }

            // Detecta hazards no pipeline
            function detectHazards() {
                if (!hazardDetectionEnabled) return;
                
                // Verifica hazards entre estágios consecutivos
                for (let cycle = 1; cycle < MAX_CYCLES; cycle++) {
                    // Data Hazard (RAW) entre EX e MEM
                    if (pipelineState[2][cycle] && pipelineState[3][cycle]) {
                        const exInstr = pipelineState[2][cycle];
                        const memInstr = pipelineState[3][cycle];
                        
                        if (exInstr && memInstr) {
                            const destReg = getDestinationRegister(exInstr.instruction);
                            const srcRegs = getSourceRegisters(memInstr.instruction);
                            
                            if (destReg && srcRegs.includes(destReg)) {
                                // Marca o hazard
                                exInstr.hazard = 'RAW';
                                memInstr.hazard = 'RAW';
                                performanceMetrics.hazards++;
                                performanceMetrics.dataHazards++;
                                
                                if (forwardingEnabled) {
                                    // Aplica forwarding
                                    exInstr.forwarding = true;
                                    memInstr.forwarding = true;
                                } else {
                                    // Insere stall
                                    insertStall(cycle);
                                }
                            }
                        }
                    }
                    
                    // Control Hazard (branch)
                    if (pipelineState[2][cycle] && pipelineState[2][cycle].type === 'branch') {
                        pipelineState[2][cycle].hazard = 'Control';
                        performanceMetrics.hazards++;
                        performanceMetrics.controlHazards++;
                        insertStall(cycle);
                        insertStall(cycle + 1);
                    }
                    
                    // Structural Hazard (MEM e WB acessando memória)
                    if (pipelineState[3][cycle] && pipelineState[4][cycle] && 
                        (pipelineState[3][cycle].type === 'load' || pipelineState[3][cycle].type === 'store') &&
                        (pipelineState[4][cycle].type === 'load' || pipelineState[4][cycle].type === 'store')) {
                        
                        pipelineState[3][cycle].hazard = 'Structural';
                        pipelineState[4][cycle].hazard = 'Structural';
                        performanceMetrics.hazards++;
                        performanceMetrics.structuralHazards++;
                        insertStall(cycle);
                    }
                }
            }

            // Insere um stall no pipeline
            function insertStall(cycle) {
                performanceMetrics.stalls++;
                
                // Move as instruções subsequentes
                for (let c = MAX_CYCLES - 1; c > cycle; c--) {
                    for (let s = 0; s < STAGES.length; s++) {
                        pipelineState[s][c] = pipelineState[s][c - 1];
                    }
                }
                
                // Insere NOPs nos estágios iniciais
                for (let s = 0; s < STAGES.length; s++) {
                    if (s <= 1) { // IF e ID recebem NOP
                        pipelineState[s][cycle] = {
                            instruction: 'NOP',
                            type: 'nop',
                            stall: true
                        };
                    } else {
                        pipelineState[s][cycle] = null;
                    }
                }
            }

            // Atualiza a visualização do pipeline
            function updatePipelineVisualization() {
                for (let stage = 0; stage < STAGES.length; stage++) {
                    for (let cycle = 0; cycle < MAX_CYCLES; cycle++) {
                        const cell = document.getElementById(`cell-${STAGES[stage]}-${cycle}`);
                        cell.className = 'pipeline-cell empty';
                        cell.innerHTML = '';
                        
                        if (pipelineState[stage][cycle]) {
                            const instr = pipelineState[stage][cycle];
                            cell.className = 'pipeline-cell filled';
                            
                            // Exibe a abreviação da instrução
                            const abbrev = abbreviateInstruction(instr.instruction);
                            cell.textContent = abbrev;
                            
                            // Adiciona tooltip com a instrução completa
                            cell.setAttribute('data-bs-toggle', 'tooltip');
                            cell.setAttribute('title', instr.instruction);
                            
                            // Marca hazards e stalls
                            if (instr.hazard) {
                                cell.classList.add(instr.hazard.toLowerCase());
                                cell.setAttribute('title', `${instr.hazard} Hazard: ${instr.instruction}`);
                            }
                            
                            if (instr.stall) {
                                cell.classList.add('stall');
                                cell.setAttribute('title', 'Stall Inserted');
                            }
                            
                            if (instr.forwarding) {
                                cell.classList.add('forwarding');
                                cell.setAttribute('title', 'Forwarding Applied');
                            }
                            
                            // Inicializa tooltip
                            new bootstrap.Tooltip(cell);
                            
                            // Adiciona animação se habilitado
                            if (animationsEnabled) {
                                cell.style.animation = 'fadeIn 0.5s';
                            }
                        }
                    }
                }
            }

            // Retorna a abreviação da instrução para exibição
            function abbreviateInstruction(instruction) {
                if (!instruction) return '';
                if (instruction === 'NOP') return 'NOP';
                
                const parts = instruction.split(' ');
                return parts.length > 0 ? parts[0] : instruction;
            }

            // Retorna o registrador de destino de uma instrução
            function getDestinationRegister(instruction) {
                if (!instruction) return null;
                
                if (instruction.startsWith('ADD') || instruction.startsWith('SUB')) {
                    return instruction.split(' ')[1].trim().replace(',', '');
                } else if (instruction.startsWith('LW')) {
                    return instruction.split(' ')[1].trim();
                }
                
                return null;
            }

            // Retorna os registradores fonte de uma instrução
            function getSourceRegisters(instruction) {
                if (!instruction) return [];
                
                const sources = [];
                
                if (instruction.startsWith('ADD') || instruction.startsWith('SUB')) {
                    const parts = instruction.split(',');
                    if (parts.length >= 3) {
                        sources.push(parts[1].trim());
                        sources.push(parts[2].trim());
                    }
                } else if (instruction.startsWith('LW')) {
                    const memPart = instruction.split(' ')[2];
                    const regPart = memPart.match(/\((.*?)\)/);
                    if (regPart && regPart[1]) {
                        sources.push(regPart[1]);
                    }
                } else if (instruction.startsWith('SW')) {
                    const parts = instruction.split(',');
                    if (parts.length >= 2) {
                        sources.push(parts[0].split(' ')[1].trim());
                        const regPart = parts[1].match(/\((.*?)\)/);
                        if (regPart && regPart[1]) {
                            sources.push(regPart[1]);
                        }
                    }
                } else if (instruction.startsWith('BEQ')) {
                    const parts = instruction.split(',');
                    if (parts.length >= 3) {
                        sources.push(parts[0].split(' ')[1].trim());
                        sources.push(parts[1].trim());
                    }
                }
                
                return sources;
            }

            // Atualiza as métricas de desempenho na UI
            function updatePerformanceMetrics() {
                document.getElementById('cycleCount').textContent = performanceMetrics.cycles;
                document.getElementById('instructionCount').textContent = performanceMetrics.instructions;
                document.getElementById('stallCount').textContent = performanceMetrics.stalls;
                document.getElementById('hazardCount').textContent = performanceMetrics.hazards;
                
                // Calcula CPI
                const cpi = performanceMetrics.instructions > 0 ? 
                    (performanceMetrics.cycles / performanceMetrics.instructions).toFixed(2) : '0.00';
                document.getElementById('cpi').textContent = cpi;
                
                // Calcula throughput
                const throughput = performanceMetrics.cycles > 0 ? 
                    (performanceMetrics.instructions / performanceMetrics.cycles).toFixed(2) : '0.00';
                document.getElementById('throughput').textContent = throughput;
                
                // Atualiza barra de eficiência
                const efficiency = performanceMetrics.cycles > 0 ? 
                    Math.min(100, Math.round((performanceMetrics.instructions / (performanceMetrics.cycles + performanceMetrics.stalls)) * 100)) : 0;
                document.getElementById('efficiencyBar').style.width = `${efficiency}%`;
            }

            // Reseta o pipeline para o estado inicial
            function resetPipeline() {
                currentCycle = 0;
                pipelineState = Array(STAGES.length).fill().map(() => Array(MAX_CYCLES).fill(null));
                performanceMetrics = {
                    cycles: 0,
                    instructions: instructions.length,
                    stalls: 0,
                    hazards: 0,
                    dataHazards: 0,
                    controlHazards: 0,
                    structuralHazards: 0
                };
                
                updatePipelineVisualization();
                updatePerformanceMetrics();
            }

            // Limpa todas as instruções e reseta o pipeline
            function clearPipeline() {
                instructions = [];
                document.getElementById('instructionsContainer').innerHTML = '';
                resetPipeline();
            }

            // Mostra o modal para adicionar nova instrução
            function showAddInstructionModal() {
                const modal = new bootstrap.Modal(document.getElementById('instructionModal'));
                modal.show();
                
                // Atualiza os campos de operando quando o tipo de instrução muda
                document.getElementById('instructionType').addEventListener('change', function() {
                    updateOperandFields(this.value);
                });
                
                // Configura os campos iniciais
                updateOperandFields(document.getElementById('instructionType').value);
            }

            // Atualiza os campos de operando baseado no tipo de instrução
            function updateOperandFields(instructionType) {
                const operandsContainer = document.getElementById('operandsContainer');
                operandsContainer.innerHTML = '';
                
                switch(instructionType) {
                    case 'add':
                    case 'sub':
                        operandsContainer.innerHTML = `
                            <div class="mb-2">
                                <label class="form-label">Registrador de destino (Rd)</label>
                                <input type="text" class="form-control" id="operandRd" placeholder="R1" value="R1">
                            </div>
                            <div class="mb-2">
                                <label class="form-label">Primeiro operando (Rs)</label>
                                <input type="text" class="form-control" id="operandRs" placeholder="R2" value="R2">
                            </div>
                            <div class="mb-2">
                                <label class="form-label">Segundo operando (Rt)</label>
                                <input type="text" class="form-control" id="operandRt" placeholder="R3" value="R3">
                            </div>
                        `;
                        break;
                        
                    case 'load':
                    case 'store':
                        operandsContainer.innerHTML = `
                            <div class="mb-2">
                                <label class="form-label">Registrador ${instructionType === 'load' ? 'de destino' : 'fonte'} (Rt)</label>
                                <input type="text" class="form-control" id="operandRt" placeholder="R4" value="R4">
                            </div>
                            <div class="mb-2">
                                <label class="form-label">Offset(Rs)</label>
                                <div class="input-group">
                                    <input type="text" class="form-control" id="operandOffset" placeholder="100" value="100">
                                    <span class="input-group-text">(</span>
                                    <input type="text" class="form-control" id="operandRs" placeholder="R5" value="R5">
                                    <span class="input-group-text">)</span>
                                </div>
                            </div>
                        `;
                        break;
                        
                    case 'branch':
                        operandsContainer.innerHTML = `
                            <div class="mb-2">
                                <label class="form-label">Primeiro registrador (Rs)</label>
                                <input type="text" class="form-control" id="operandRs" placeholder="R6" value="R6">
                            </div>
                            <div class="mb-2">
                                <label class="form-label">Segundo registrador (Rt)</label>
                                <input type="text" class="form-control" id="operandRt" placeholder="R7" value="R7">
                            </div>
                            <div class="mb-2">
                                <label class="form-label">Label de destino</label>
                                <input type="text" class="form-control" id="operandLabel" placeholder="loop" value="Label">
                            </div>
                        `;
                        break;
                        
                    case 'nop':
                        operandsContainer.innerHTML = `
                            <div class="alert alert-info">
                                NOP (No Operation) não requer operandos.
                            </div>
                        `;
                        break;
                }
            }

            // Adiciona uma nova instrução baseada nos valores do modal
            function addCustomInstruction() {
                const instructionType = document.getElementById('instructionType').value;
                let instructionText = '';
                
                switch (instructionType) {
                    case 'add':
                        const rdAdd = document.getElementById('operandRd').value || 'R1';
                        const rsAdd = document.getElementById('operandRs').value || 'R2';
                        const rtAdd = document.getElementById('operandRt').value || 'R3';
                        instructionText = `ADD ${rdAdd}, ${rsAdd}, ${rtAdd}`;
                        break;
                        
                    case 'sub':
                        const rdSub = document.getElementById('operandRd').value || 'R1';
                        const rsSub = document.getElementById('operandRs').value || 'R2';
                        const rtSub = document.getElementById('operandRt').value || 'R3';
                        instructionText = `SUB ${rdSub}, ${rsSub}, ${rtSub}`;
                        break;
                        
                    case 'load':
                        const rtLoad = document.getElementById('operandRt').value || 'R4';
                        const offsetLoad = document.getElementById('operandOffset').value || '100';
                        const rsLoad = document.getElementById('operandRs').value || 'R5';
                        instructionText = `LW ${rtLoad}, ${offsetLoad}(${rsLoad})`;
                        break;
                        
                    case 'store':
                        const rtStore = document.getElementById('operandRt').value || 'R6';
                        const offsetStore = document.getElementById('operandOffset').value || '200';
                        const rsStore = document.getElementById('operandRs').value || 'R7';
                        instructionText = `SW ${rtStore}, ${offsetStore}(${rsStore})`;
                        break;
                        
                    case 'branch':
                        const rsBranch = document.getElementById('operandRs').value || 'R8';
                        const rtBranch = document.getElementById('operandRt').value || 'R9';
                        const label = document.getElementById('operandLabel').value || 'Label';
                        instructionText = `BEQ ${rsBranch}, ${rtBranch}, ${label}`;
                        break;
                        
                    case 'nop':
                        instructionText = 'NOP';
                        break;
                }
                
                addInstruction(instructionText, instructionType);
                
                // Fecha o modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('instructionModal'));
                modal.hide();
            }

            // Inicializa o simulador
            initializePipelineGrid();
            
            // Adiciona algumas instruções de exemplo
            addInstruction('ADD R1, R2, R3', 'add');
            addInstruction('LW R4, 100(R5)', 'load');
            addInstruction('SW R6, 200(R7)', 'store');
            addInstruction('BEQ R8, R9, Label', 'branch');
            addInstruction('NOP', 'nop');
            
            // Configura os event listeners
            document.getElementById('runPipelineBtn').addEventListener('click', runPipeline);
            document.getElementById('stepPipelineBtn').addEventListener('click', stepPipeline);
            document.getElementById('resetPipelineBtn').addEventListener('click', resetPipeline);
            document.getElementById('addInstructionBtn').addEventListener('click', showAddInstructionModal);
            document.getElementById('clearPipelineBtn').addEventListener('click', clearPipeline);
            document.getElementById('forwardingToggle').addEventListener('change', function() {
                forwardingEnabled = this.checked;
            });
            document.getElementById('hazardDetectionToggle').addEventListener('change', function() {
                hazardDetectionEnabled = this.checked;
            });
            document.getElementById('animationToggle').addEventListener('change', function() {
                animationsEnabled = this.checked;
            });
            document.getElementById('confirmAddInstruction').addEventListener('click', addCustomInstruction);
            
            // Torna as instruções arrastáveis
            new Sortable(document.getElementById('instructionsContainer'), {
                animation: 150,
                ghostClass: 'bg-light',
                onEnd: function(evt) {
                    // Reordena o array de instruções quando uma instrução é movida
                    const items = evt.from.children;
                    const newInstructions = [];
                    
                    for (let i = 0; i < items.length; i++) {
                        const id = items[i].id;
                        const originalInstr = instructions.find(inst => inst.id === id);
                        if (originalInstr) {
                            newInstructions.push(originalInstr);
                        }
                    }
                    
                    instructions = newInstructions;
                }
            });
        });
    </script>
</body>
</html>